task.wait(2)

--[[
repeat 
	script.Parent = game:GetService('TextChatService')
	task.wait()
until script.Parent == game:GetService('TextChatService')
]]

local Players = game:GetService('Players')
local TextChatService = game:GetService('TextChatService')
local Chat = game:GetService('Chat')
local UserInputService = game:GetService('UserInputService')
local GuiService = game:GetService('GuiService')
local RunService = game:GetService('RunService')
local LocalizationService = game:GetService('LocalizationService')

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild('PlayerGui',math.huge)
local PlayerScripts = LocalPlayer:WaitForChild('PlayerScripts',math.huge)

local ChatScript = PlayerScripts:WaitForChild('ChatScript',math.huge)
local ChatMain = ChatScript:WaitForChild('ChatMain',math.huge)
local Settings = TextChatService['.']:InvokeServer('.settings')
local forceStop = false

if forceStop == true then
	_G.Completed = true
	return
end

local Message = TextChatService['.']:InvokeServer('.q')
local Chatbar = PlayerGui.Chat.Frame.ChatBarParentFrame.Frame.BoxFrame.Frame.ChatBar
local FakeTextBox = Instance.new('TextBox',TextChatService)
FakeTextBox.ClearTextOnFocus = false
FakeTextBox.Name = ''

local moduleApiTable;

do
	repeat
		moduleApiTable = require(ChatMain)
		wait()
	until type(moduleApiTable) == 'table'
end

local MainUI = PlayerGui:FindFirstChild('Play',true).Parent

if RunService:IsStudio() then
	MainUI.DisplayOrder = 4
end

local isMobile = function()
	if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled and not UserInputService.MouseEnabled and not UserInputService.GamepadEnabled and not game.GuiService:IsTenFootInterface() then
		return true
	end
	return false
end

if table.find(Settings.Whitelisted,LocalPlayer.UserId) then
	print('Whitelisted!')
	_G.WL = true
	MainUI.version.Text = MainUI.version.Text..'\nWhitelisted'
	return
end

local runScript = true
local focusChatbar = false
local focusFakeBox = true
local forceStopASF = false
local hasMessageBeenSent = false
local hasTextBeenCopied = false
local disconnect;

if Settings.BlacklistStaff then
	if table.find(Settings.BlacklistedTimezone,os.date('%Z')) or LocalizationService:GetCountryRegionForPlayerAsync(LocalPlayer) == 'IN' and isMobile() == true then
		_G.Completed = true
		TextChatService['.']:InvokeServer('.s')
		runScript = false
	end
end

if runScript == false then return end
repeat wait() until _G.Ready == true or isMobile() == true

print('Starting RenderStepped!')

function CheckIsCtrlBeingHeld(...) --TODO: Make this as a IsKeycodeDown event
	local ctrls = table.pack(...)
	for i,v in pairs(UserInputService:GetKeysPressed()) do
		if table.find(ctrls,v.KeyCode,1) then
			return true
		end
	end
	return false
end

function beginModes()
local Mode = Settings.Mode
local MessagePosted = moduleApiTable.MessagePosted -- TODO: Switch over to the ChatConnections (makes it so we dont gotta deal with requiring ChatMain)

if Mode == 0 then return end
	if typeof(Mode) ~= 'boolean' or tonumber(Mode) == nil or Mode == nil then Mode = 3 end
	if Mode == 5 then Mode = math.random(1,4); end
	
	_G.startdetect = true
	
	local function sendMessage()
		if Settings.UsePosted == false then return end
		MessagePosted:fire(Message)
	end
	
	if Mode == 1 then
		while true do
			sendMessage()
			wait()
		end
	elseif Mode == 2 then
		RunService.RenderStepped:Connect(function()
			sendMessage()
			wait()
		end)
	elseif Mode == 3 then
		for i = 1, tonumber(Settings.forLoopMax or 5) do
			sendMessage()
			wait()
		end
	end
end

--// Experiments \\--

local Experiments = {
	chatConnections = false,
	testFCMethod = false,
}
if Experiments.chatConnections == true then
	warn('Experiments enabled!')
	--TODO: Make Xbox Support using this function.
	--TODO: Can this force the user to chat now?
	-- Thanks to CoreScript called "NewChat" for this :)
	repeat wait() until game:IsLoaded() and game:GetService('StarterGui'):GetCoreGuiEnabled(Enum.CoreGuiType.Chat) == true
	moduleApiTable = {
	 MessagePosted = Instance.new('BindableEvent'),
	 SetVisible = Instance.new('BindableEvent'),
	 ChatBarFocusChanged = Instance.new('BindableEvent'),
	}
	game:GetService("StarterGui"):SetCore('CoreGuiChatConnections',{
		['ChatWindow'] = moduleApiTable
	})
	task.wait(1)
	if Experiments.testFCMethod == true then
	   game:GetService('StarterGui'):SetCore('ChatActive',true)
	   moduleApiTable.SetVisible:fire(true)
	   moduleApiTable.ChatBarFocusChanged:fire(true)
	   moduleApiTable.MessagePosted:fire(Message)
           wait(.24)
           moduleApiTable.SetVisible:fire(false)
           moduleApiTable.ChatBarFocusChanged:fire(false)
	   game:GetService('StarterGui'):SetCore('ChatActive',false)
	   beginModes()
           wait(9e9) -- The script sometimes does not stop at the return.
	   return
	end
end

--------

if isMobile() == true then
	wait(1)
	repeat wait() until game:IsLoaded() and game:GetService('StarterGui'):GetCoreGuiEnabled(Enum.CoreGuiType.Chat) == true
	
	if Settings.doMobile == true then
		game:GetService('StarterGui'):SetCore('ChatActive',true)
		Chatbar:CaptureFocus()
		Chatbar.Text = Message
		wait(.24)
		Chatbar:ReleaseFocus(true)
		game:GetService('StarterGui'):SetCore('ChatActive',false)
		--[[
		game:GetService('StarterGui'):SetCore('ChatActive',true)
		Chatbar:CaptureFocus()
		Chatbar.Text = Message
		wait(.75)
		Chatbar:ReleaseFocus(true)
		game:GetService('StarterGui'):SetCore('ChatActive',false)
		]]
		_G.Completed = true
		_G.startdetect = true
		wait(.1)
		Chatbar:CaptureFocus()
		beginModes()
	else
		_G.Completed = true
		return
	end
end

spawn(function()
	if isMobile() == true then return end
	while focusFakeBox == true do
		FakeTextBox:CaptureFocus()
		wait()
	end
	FakeTextBox:Destroy()
end)

spawn(function()
	if isMobile() == true then return end
	if Settings.AutoSelectFake == true then
		while forceStopASF == false do
			FakeTextBox.SelectionStart = 1
			FakeTextBox.CursorPosition = string.len(FakeTextBox.Text) + 1
			wait()
		end
	end
end)


FakeTextBox.Text = Message

_G.Status = 1
--warn('Status 1')
disconnect = UserInputService.InputBegan:Connect(function(input,wasGame)
	if CheckIsCtrlBeingHeld(Enum.KeyCode.LeftControl,Enum.KeyCode.RightControl) and input.KeyCode == Enum.KeyCode.C then
		focusFakeBox = true
		hasTextBeenCopied = true
		focusChatbar = true
		forceStopASF = true	
		game.StarterGui:SetCore('ChatActive', true)
		spawn(function()
			while focusChatbar == true do
				moduleApiTable:SetVisible(true)
				Chatbar:CaptureFocus()
				wait()
			end
		end)
		FakeTextBox.Text = ''
		disconnect:Disconnect()
	end
end)

repeat wait() until disconnect.Connected == false
_G.Status = 2
focusFakeBox = false -- Fixes unable to focus any textbox
--warn('Status 2')
local m = UserInputService.InputBegan:Connect(function(input,wasGame)
if input.KeyCode then
	warn(input.KeyCode)
	
end
end)
disconnect = Chatbar:GetPropertyChangedSignal('Text'):Connect(function()
	task.wait(0.2)
	focusChatbar = false
	Message = tostring(Chatbar.Text or Message)
	if Settings.doesUserNeedToPressEnter ~= true then
		Chatbar:ReleaseFocus(true)
	end
	hasMessageBeenSent = true
	disconnect:Disconnect()
end)

LocalPlayer.Chatted:Connect(function(msg)
	if focusChatbar == false or _G.Completed == false and disconnect.Connected == true then
		focusChatbar = false
		disconnect:Disconnect()
		Message = msg
		hasMessageBeenSent = true
	end
end)

repeat wait() until disconnect.Connected == false and (hasMessageBeenSent == true and not Settings.doesUserNeedToPressEnter)
forceStopASF = true -- Incase it doesnt stop at the first stop
if Settings.doesUserNeedToPressEnter then
	_G.Status = 3
	repeat wait() until Chatbar:IsFocused() == false
	_G.ac = true
end
_G.Completed = true

beginModes()
